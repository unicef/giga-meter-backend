import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import * as jwt from 'jsonwebtoken';
import * as jwksRsa from 'jwks-rsa';
import { Category, DEFAULT_CATEGORY } from '../common/category.config';
import { Reflector } from '@nestjs/core';
import { IS_PUBLIC_KEY } from '../common/public.decorator';
import { firstValueFrom } from 'rxjs';
import { ValidateApiKeyDto } from './auth.dto';
import { HttpService } from '@nestjs/axios';
import { CategoryConfigProvider } from '../common/category-config.provider';



@Injectable()
export class AuthGuard implements CanActivate {

  constructor(
    private readonly httpService: HttpService,
    private readonly categoryConfigProvider: CategoryConfigProvider,
    private reflector: Reflector,
  ) { }

  async canActivate(context: ExecutionContext): Promise<boolean> {
    // Check if the route is marked as public
    const request = context.switchToHttp().getRequest();
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (isPublic) {
      return true;
    }

    const useAuth = process.env.USE_AUTH === 'true';
    const authHeader = request.headers.authorization;
    if (!useAuth) return true;
    
    // Check if it's a Bearer token or device token
    const parts = authHeader.split(' ');
    if (parts.length !== 2) {
      throw new UnauthorizedException('Invalid authorization header format');
    }

    const [scheme, token] = parts;
    
    // Handle Bearer tokens (existing logic)
    if (scheme.toLowerCase() === 'bearer') {
      if (request.headers?.tokentype === 'b2c') {
        const response = await this.validateB2cToken(token);
        if (!response) {
          throw new UnauthorizedException(
            'Invalid bearer token or not authorized to access for b2c',
          );
        }
        request.category = Category.ADMIN;
        request.b2cUser = response;
        return true;
      }
    }
    
    // Bypass authentication for Prometheus metrics endpoint
    if (request.url === '/metrics') {
      return true;
    }
    const token = request.headers.authorization?.split(' ')[1];

    if (!token) {
      throw new UnauthorizedException('Missing authorization token');
    }

    const response = await this.validateToken(token, request);
    if (!response) {
      throw new UnauthorizedException(
        'Invalid token or not authorized to access',
      );
    }
    return true;
  }

  public async validateToken(token: string, request: any): Promise<boolean> {
    try {
      const url = `${process.env.PROJECT_CONNECT_SERVICE_URL}/api/v1/validate_api_key/${process.env.DAILY_CHECK_APP_API_CODE}`;
      const response = await firstValueFrom(
        this.httpService.get<ValidateApiKeyDto>(url, {
          headers: { Authorization: `Bearer ${token}` },
        }),
      );
      if (
        !response.data.success ||
        (!response.data.data.has_write_access &&
          (/*request?.method != 'GET' ||*/
            response.data.data.countries?.length === 0))
      ) {
        return false;
      }

      request.has_write_access = response.data.data.has_write_access;
      const apiCategory = response?.data?.data?.apiCategory?.code;
      // Extract and set the category from the response
      //TODO:// remove this logic after swagger categories are added 
      request.category = (apiCategory ? apiCategory : request.has_write_access ? Category.GIGA_METER : DEFAULT_CATEGORY).toLowerCase();

      //TODO:// remove this logic after swagger categories are added 
      if (request?.method == 'GET' && !response.data.data.has_write_access) {
        request.allowed_countries = response.data.data.countries.map(
          (c) => c.code,
        );
        request.allowed_countries_iso3 = response.data.data.countries.map(
          (c) => c.iso3_format,
        );
        request.allowed_countries_map = response.data.data.countries.reduce((acc, country) => {
          acc[country.code] = country.iso3_format;
          return acc;
        }, {});
      }
      const config = await this.categoryConfigProvider.getCategoryConfig(request.category);
      request.category_allowed_countries = config?.allowedCountries ?? [];

      return true;
    } catch (error) {
      console.error('Token validation failed:', error.message);
      return false;
    }
  }
}
